# Overview
The `fpm_compile_commands` module provides the functionality to generate and manage `compile_commands.json` files. These JSON files contain a list of precise compile commands used for each source file in a project. This information is valuable for various development tools, particularly language servers (e.g., for code completion, navigation, and diagnostics) and some static analyzers, as it allows them to understand the build environment and compiler options for each file.

The module defines two main derived types: `compile_command_t` for individual compilation entries and `compile_command_table_t` to hold a collection of these entries. It includes procedures to populate these types from actual build commands and to serialize them into the JSON format required for `compile_commands.json`.

# Key Components
- **`compile_command_t`**: A derived type (extending `serializable_t` for TOML/JSON operations) representing a single entry in the `compile_commands.json` file.
  - `directory`: A `string_t` specifying the working directory where the compilation was performed.
  - `arguments`: An allocatable array of `string_t`, holding the compiler executable and its arguments as a list of strings.
  - `file`: A `string_t` specifying the path to the source file being compiled.
  - Procedures: `destroy`, `serializable_is_same`, `dump_to_toml`, `load_from_toml`.
  - Constructor: `cct_new(directory, arguments, file)` (Note: name `cct_new` is slightly confusing here, seems like it should be `compile_command_new`).
- **`compile_command_table_t`**: A derived type (extending `serializable_t`) representing the entire `compile_commands.json` structure, which is essentially an array of `compile_command_t` objects.
  - `command`: An allocatable array of `compile_command_t`, storing all the compile commands.
  - Procedures:
    - `destroy` (`cct_destroy`): Cleans up the table.
    - `write` (`cct_write`): Writes the table to a `compile_commands.json` file. This uses a custom JSON serialization approach with `jonquil` because `jonquil` (at the time of writing) might not directly support unnamed top-level arrays as required by the `compile_commands.json` standard.
    - `register` (generic for `cct_register` and `cct_register_object`):
      - `cct_register(self, command, target_os, error)`: Parses a full command string (using `shlex_module` for tokenization based on OS), identifies the source file, and adds a new `compile_command_t` entry to the table. This is thread-safe using `!$omp critical`.
      - `cct_register_object(self, command, error)`: Adds a pre-constructed `compile_command_t` object to the table.
    - `serializable_is_same`, `dump_to_toml`, `load_from_toml`: For serialization.
    - `cct_dump_array`: Helper to dump the commands into a `toml_array`.

# Important Variables/Constants
N/A directly in this module, but it relies on constants from other modules (e.g., `OS_WINDOWS` from `fpm_environment`).

# Usage Examples
This module is primarily used by the `fpm_backend` during the build process. When a source file is compiled, the `fpm_backend` (specifically through the compiler abstraction layer) will register the compilation command with an instance of `compile_command_table_t`.

Conceptual workflow:
1. An instance of `compile_command_table_t` is created (e.g., in `fpm_backend_output`'s `build_progress_t`).
2. For each Fortran/C/C++ source file compiled:
   a. The full compile command string is generated by the compiler driver (e.g., `model%compiler%compile_fortran`).
   b. This command string is passed to `compile_command_table_t%register(full_command_string, target_os, error)`.
   c. `cct_register` tokenizes the command, extracts the source file name, gets the current working directory, and creates a `compile_command_t` object.
   d. This object is added to the `command` array within the table.
3. After all compilations (or at the end of the build process), `compile_command_table_t%write("build/compile_commands.json", error)` is called to serialize the collected commands into the `compile_commands.json` file.

```fortran
! Conceptual usage within a build system
use fpm_compile_commands
use fpm_os, only: get_current_directory
use fpm_environment, only: OS_LINUX ! Example OS
implicit none

type(compile_command_table_t) :: compile_db
character(len=:), allocatable :: error_msg, cwd
type(error_t), allocatable :: err

call compile_db%destroy() ! Initialize/clear

! Simulate registering a command
character(len=200) :: cmd_string1 = "gfortran -c -o build/src_my_module.f90.o src/my_module.f90 -Ibuild/include"
call compile_db%register(cmd_string1, OS_LINUX, err)
if (allocated(err)) then
    print *, "Error registering command 1: ", err%message
    stop 1
end if

! ... (more commands registered) ...

! Write to file
call get_current_directory(cwd, err) ! Or a specific build directory
call compile_db%write(trim(cwd)//"/compile_commands.json", err)
if (allocated(err)) then
    print *, "Error writing compile_commands.json: ", err%message
    stop 1
end if

print *, "compile_commands.json generated."
```

# Dependencies and Interactions
- **`fpm_toml`**: For `serializable_t` base type and TOML serialization/deserialization helpers (`set_string`, `set_list`, `get_value`, `get_list`, `add_table`, `toml_array`, `add_array`). Although the final output is JSON, TOML structures are used internally as an intermediate step for serialization.
- **`tomlf`**: For `toml_table` type.
- **`jonquil`**: For `json_serialize` and `json_ser_config`, used in the `cct_write` procedure to generate the final JSON output.
- **`fpm_strings`**: For `string_t` type and its operations.
- **`fpm_error`**: For error handling types and procedures (`error_t`, `syntax_error`, `fatal_error`).
- **`fpm_os`**: For `get_current_directory`.
- **`fpm_environment`**: For `get_os_type` and OS constants like `OS_WINDOWS` (to select appropriate command line splitting).
- **`shlex_module`**: For `sh_split` (POSIX-like shell command splitting) and `ms_split` (Windows command splitting) to tokenize command strings into arguments.
- **`fpm_backend`**: The primary client of this module. The backend calls `register` to add commands during compilation and `write` to save the file.
- **OpenMP**: The `cct_register` procedure uses `!$omp critical (command_update)` to ensure thread-safe updates to the command table when fpm is built with OpenMP and performs parallel compilations.
